
.. _program_listing_file__Users_enrico_Ricerca_develop_C++_pins-mechatronix_LibSources_submodules_Splines_src_Splines.hh:

Program Listing for File Splines.hh
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_enrico_Ricerca_develop_C++_pins-mechatronix_LibSources_submodules_Splines_src_Splines.hh>` (``/Users/enrico/Ricerca/develop/C++/pins-mechatronix/LibSources/submodules/Splines/src/Splines.hh``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*--------------------------------------------------------------------------*\
    |                                                                          |
    |  Copyright (C) 2016                                                      |
    |                                                                          |
    |         , __                 , __                                        |
    |        /|/  \               /|/  \                                       |
    |         | __/ _   ,_         | __/ _   ,_                                |
    |         |   \|/  /  |  |   | |   \|/  /  |  |   |                        |
    |         |(__/|__/   |_/ \_/|/|(__/|__/   |_/ \_/|/                       |
    |                           /|                   /|                        |
    |                           \|                   \|                        |
    |                                                                          |
    |      Enrico Bertolazzi                                                   |
    |      Dipartimento di Ingegneria Industriale                              |
    |      Universita` degli Studi di Trento                                   |
    |      email: enrico.bertolazzi@unitn.it                                   |
    |                                                                          |
   \*--------------------------------------------------------------------------*/
   
   #pragma once
   
   #ifndef SPLINES_HH
   #define SPLINES_HH
   
   #ifdef __GNUC__
   #pragma GCC diagnostic push
   #endif
   
   #ifdef __clang__
   #pragma clang diagnostic push
   #pragma clang diagnostic ignored "-Wc++98-compat"
   #pragma clang diagnostic ignored "-Wglobal-constructors"
   #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
   #pragma clang diagnostic ignored "-Wpoison-system-directories"
   #endif
   
   #include "SplinesConfig.hh"
   #include <fstream>
   
   namespace Splines {
   
     using std::vector;
     using std::string;
     using std::exception;
     using std::runtime_error;
     using std::basic_ostream;
     using std::ostringstream;
     using std::lower_bound;
     using std::pair;
     using std::cerr;
   
     typedef double real_type; 
     typedef int    integer;   
     typedef basic_ostream<char> ostream_type;
   
     void backtrace( ostream_type & );
   
     typedef enum {
       CONSTANT_TYPE   = 0,
       LINEAR_TYPE     = 1,
       CUBIC_TYPE      = 2,
       AKIMA_TYPE      = 3,
       BESSEL_TYPE     = 4,
       PCHIP_TYPE      = 5,
       QUINTIC_TYPE    = 6,
       HERMITE_TYPE    = 7,
       SPLINE_SET_TYPE = 8,
       SPLINE_VEC_TYPE = 9
     } SplineType1D;
   
     typedef enum {
       BILINEAR_TYPE  = 0,
       BICUBIC_TYPE   = 1,
       BIQUINTIC_TYPE = 2,
       AKIMA2D_TYPE   = 3
     } SplineType2D;
   
     extern char const *spline_type_1D[];
   
     #ifndef DOXYGEN_SHOULD_SKIP_THIS
     extern SplineType1D string_to_splineType( string const & n );
     #endif
   
     using GenericContainerNamespace::GenericContainer;
     using GenericContainerNamespace::vec_real_type;
     using GenericContainerNamespace::vec_string_type;
     using GenericContainerNamespace::vector_type;
     using GenericContainerNamespace::map_type;
   
     /*
     //   _   _                     _ _
     //  | | | | ___ _ __ _ __ ___ (_) |_ ___
     //  | |_| |/ _ \ '__| '_ ` _ \| | __/ _ \
     //  |  _  |  __/ |  | | | | | | | ||  __/
     //  |_| |_|\___|_|  |_| |_| |_|_|\__\___|
     */
   
     #ifndef DOXYGEN_SHOULD_SKIP_THIS
   
     void Hermite3( real_type x, real_type H, real_type base[4] );
     void Hermite3_D( real_type x, real_type H, real_type base_D[4] );
     void Hermite3_DD( real_type x, real_type H, real_type base_DD[4] );
     void Hermite3_DDD( real_type x, real_type H, real_type base_DDD[4] );
   
     void Hermite5( real_type x, real_type H, real_type base[6] );
     void Hermite5_D( real_type x, real_type H, real_type base_D[6] );
     void Hermite5_DD( real_type x, real_type H, real_type base_DD[6] );
     void Hermite5_DDD( real_type x, real_type H, real_type base_DDD[6] );
     void Hermite5_DDDD( real_type x, real_type H, real_type base_DDDD[6] );
     void Hermite5_DDDDD( real_type x, real_type H, real_type base_DDDDD[6] );
   
     #endif
   
     /*
     //   ____  _ _ _
     //  | __ )(_) (_)_ __   ___  __ _ _ __
     //  |  _ \| | | | '_ \ / _ \/ _` | '__|
     //  | |_) | | | | | | |  __/ (_| | |
     //  |____/|_|_|_|_| |_|\___|\__,_|_|
     */
   
     #ifndef DOXYGEN_SHOULD_SKIP_THIS
   
     real_type
     bilinear3(
       real_type const p[4],
       real_type const M[4][4],
       real_type const q[4]
     );
   
     real_type
     bilinear5(
       real_type const p[6],
       real_type const M[6][6],
       real_type const q[6]
     );
   
     integer
     checkCubicSplineMonotonicity(
       real_type const * X,
       real_type const * Y,
       real_type const * Yp,
       integer           npts
     );
   
     #endif
   
     /*\
      |  ____                                _        _          _   _
      | |  _ \ __ _ _ __ __ _ _ __ ___   ___| |_ _ __(_)______ _| |_(_) ___  _ __
      | | |_) / _` | '__/ _` | '_ ` _ \ / _ \ __| '__| |_  / _` | __| |/ _ \| '_ \
      | |  __/ (_| | | | (_| | | | | | |  __/ |_| |  | |/ / (_| | |_| | (_) | | | |
      | |_|   \__,_|_|  \__,_|_| |_| |_|\___|\__|_|  |_/___\__,_|\__|_|\___/|_| |_|
      |
     \*/
   
     void
     uniform(
       integer           dim,
       integer           npts,
       real_type const * pnts,
       integer           ld_pnts,
       real_type       * t
     );
   
     void
     chordal(
       integer           dim,
       integer           npts,
       real_type const * pnts,
       integer           ld_pnts,
       real_type       * t
     );
   
     void
     centripetal(
       integer           dim,
       integer           npts,
       real_type const * pnts,
       integer           ld_pnts,
       real_type         alpha,
       real_type       * t
     );
   
     void
     universal(
       integer           dim,
       integer           npts,
       real_type const * pnts,
       integer           ld_pnts,
       real_type       * t
     );
   
     void
     FoleyNielsen(
       integer           dim,
       integer           npts,
       real_type const * pnts,
       integer           ld_pnts,
       real_type       * t
     );
   
     void
     FangHung(
       integer           dim,
       integer           npts,
       real_type const * pnts,
       integer           ld_pnts,
       real_type       * t
     );
   
     /*\
      |   ____        _ _
      |  / ___| _ __ | (_)_ __   ___
      |  \___ \| '_ \| | | '_ \ / _ \
      |   ___) | |_) | | | | | |  __/
      |  |____/| .__/|_|_|_| |_|\___|
      |        |_|
     \*/
     class Spline {
       friend class SplineSet;
     protected:
   
       string m_name;
       bool   m_curve_is_closed;
       bool   m_curve_can_extend;
       bool   m_curve_extended_constant;
   
       integer   m_npts;
       integer   m_npts_reserved;
       real_type *m_X; // allocated in the derived class!
       real_type *m_Y; // allocated in the derived class!
   
       mutable Utils::BinarySearch<integer> m_bs;
   
       void initLastInterval();
   
       Spline( Spline const & ) = delete;
       Spline const & operator = ( Spline const & ) = delete;
   
     public:
   
       Spline( string const & name = "Spline" )
       : m_name(name)
       , m_curve_is_closed(false)
       , m_curve_can_extend(true)
       , m_curve_extended_constant(false)
       , m_npts(0)
       , m_npts_reserved(0)
       , m_X(nullptr)
       , m_Y(nullptr)
       {
         this->initLastInterval();
       }
       virtual
       ~Spline()
       {}
   
       integer search( real_type & x ) const;
   
   
       string const & name() const { return m_name; }
   
       bool is_closed() const { return m_curve_is_closed;  }
       void make_closed()     { m_curve_is_closed = true;  }
       void make_opened()     { m_curve_is_closed = false; }
   
       bool is_bounded() const { return !m_curve_can_extend; }
       void make_unbounded()   { m_curve_can_extend = true;  }
       void make_bounded()     { m_curve_can_extend = false; }
   
       bool is_extended_constant() const { return m_curve_extended_constant;  }
       void make_extended_constant()     { m_curve_extended_constant = true;  }
       void make_extended_not_constant() { m_curve_extended_constant = false; }
   
       integer numPoints() const { return m_npts; }
   
       real_type xNode( integer i ) const { return m_X[size_t(i)]; }
   
       real_type yNode( integer i ) const { return m_Y[size_t(i)]; }
   
       real_type xBegin() const { return m_X[0]; }
   
       real_type yBegin() const { return m_Y[0]; }
   
       real_type xEnd() const { return m_X[size_t(m_npts-1)]; }
   
       real_type yEnd() const { return m_Y[size_t(m_npts-1)]; }
   
       real_type xMin() const { return m_X[0]; }
   
       real_type xMax() const { return m_X[m_npts-1]; }
   
       real_type
       yMin() const {
         integer N = m_npts;
         if ( type() == CONSTANT_TYPE ) --N;
         return *std::min_element(m_Y,m_Y+N);
       }
   
       real_type
       yMax() const {
         integer N = m_npts;
         if ( type() == CONSTANT_TYPE ) --N;
         return *std::max_element(m_Y,m_Y+N);
       }
   
       void setOrigin( real_type x0 );
   
       void setRange( real_type xmin, real_type xmax );
   
   
   
       void
       build( GenericContainer const & gc )
       { setup(gc); }
   
       virtual
       void
       build(
         real_type const * x, integer incx,
         real_type const * y, integer incy,
         integer n
       );
   
       inline
       void
       build(
         real_type const * x,
         real_type const * y,
         integer           n
       )
       { this->build( x, 1, y, 1, n ); }
   
       inline
       void
       build( vector<real_type> const & x, vector<real_type> const & y ) {
         integer N = integer(x.size());
         if ( N > integer(y.size()) ) N = integer(y.size());
         this->build( &x.front(), 1, &y.front(), 1, N );
       }
   
       virtual
       void build() = 0;
   
       virtual
       void setup( GenericContainer const & gc );
   
   
   
       virtual
       void reserve( integer npts ) = 0;
   
       void pushBack( real_type x, real_type y );
   
       void dropBack() { if ( m_npts > 0 ) --m_npts; }
   
       virtual
       void clear() = 0;
   
   
   
       void
       dump(
         ostream_type & s,
         integer        nintervals,
         char const *   header = "x\ty"
       ) const;
   
       void
       dump(
         char const * fname,
         integer      nintervals,
         char const * header = "x\ty"
       ) const {
         std::ofstream file(fname);
         this->dump( file, nintervals, header );
         file.close();
       }
   
       virtual
       void writeToStream( ostream_type & s ) const = 0;
   
   
   
       virtual
       real_type operator () ( real_type x ) const = 0;
   
       virtual
       real_type D( real_type x ) const = 0;
   
       virtual
       real_type DD( real_type x ) const = 0;
   
       virtual
       real_type DDD( real_type x ) const = 0;
   
       virtual
       real_type DDDD( real_type ) const { return real_type(0); }
   
       virtual
       real_type DDDDD( real_type ) const { return real_type(0); }
   
       real_type eval( real_type x ) const { return (*this)(x); }
       real_type eval_D( real_type x ) const { return this->D(x); }
       real_type eval_DD( real_type x ) const { return this->DD(x); }
       real_type eval_DDD( real_type x ) const { return this->DDD(x); }
       real_type eval_DDDD( real_type x ) const { return this->DDDD(x); }
       real_type eval_DDDDD( real_type x ) const { return this->DDDDD(x); }
   
       virtual
       real_type id_eval( integer ni, real_type x ) const = 0;
   
       virtual
       real_type id_D( integer ni, real_type x ) const = 0;
   
       virtual
       real_type id_DD( integer ni, real_type x ) const = 0;
   
       virtual
       real_type id_DDD( integer ni, real_type x ) const = 0;
   
       virtual
       real_type id_DDDD( integer, real_type ) const { return real_type(0); }
   
       virtual
       real_type id_DDDDD( integer, real_type ) const { return real_type(0); }
   
   
   
       virtual
       integer // order
       coeffs(
         real_type * const cfs,
         real_type * const nodes,
         bool              transpose = false
       ) const = 0;
   
       virtual
       integer
       order() const = 0;
       char const *
       type_name() const
       { return Splines::spline_type_1D[type()]; }
   
       virtual
       unsigned type() const = 0;
   
       string info() const;
   
       void info( ostream_type & stream ) const { stream << this->info() << '\n'; }
   
   
     };
   
     real_type
     curvature( real_type s, Spline const & X, Spline const & Y );
   
     real_type
     curvature_D( real_type s, Spline const & X, Spline const & Y );
   
     real_type
     curvature_DD( real_type s, Spline const & X, Spline const & Y );
   
     /*\
      |    ____      _     _        ____        _ _              ____
      |   / ___|   _| |__ (_) ___  / ___| _ __ | (_)_ __   ___  | __ )  __ _ ___  ___
      |  | |  | | | | '_ \| |/ __| \___ \| '_ \| | | '_ \ / _ \ |  _ \ / _` / __|/ _ \
      |  | |__| |_| | |_) | | (__   ___) | |_) | | | | | |  __/ | |_) | (_| \__ \  __/
      |   \____\__,_|_.__/|_|\___| |____/| .__/|_|_|_| |_|\___| |____/ \__,_|___/\___|
      |                                  |_|
     \*/
     class CubicSplineBase : public Spline {
     protected:
       Utils::Malloc<real_type> m_baseValue;
   
       real_type * m_Yp;
       bool        m_external_alloc;
   
     public:
   
       #ifndef DOXYGEN_SHOULD_SKIP_THIS
       using Spline::build;
       #endif
   
       CubicSplineBase( string const & name = "CubicSplineBase" )
       : Spline(name)
       , m_baseValue(name+"_memory")
       , m_Yp(nullptr)
       , m_external_alloc(false)
       {}
   
       ~CubicSplineBase() override {}
   
       void
       copySpline( CubicSplineBase const & S );
   
       real_type
       ypNode( integer i ) const
       { return m_Yp[size_t(i)]; }
   
       void
       setRange( real_type xmin, real_type xmax );
   
       void
       reserve_external(
         integer       n,
         real_type * & p_x,
         real_type * & p_y,
         real_type * & p_dy
       );
   
       // --------------------------- VIRTUALS -----------------------------------
   
       real_type operator () ( real_type x ) const override;
       real_type D( real_type x ) const override;
       real_type DD( real_type x ) const override;
       real_type DDD( real_type x ) const override;
       real_type id_eval( integer ni, real_type x ) const override;
       real_type id_D( integer ni, real_type x ) const override;
       real_type id_DD( integer ni, real_type x ) const override;
       real_type id_DDD( integer ni, real_type x ) const override;
   
       void writeToStream( ostream_type & s ) const override;
   
       // --------------------------- VIRTUALS -----------------------------------
   
       void reserve( integer npts ) override;
   
       // must be defined in derived classes
       void
       build(
         real_type const * x,  integer incx,
         real_type const * y,  integer incy,
         real_type const * yp, integer incyp,
         integer n
       );
   
       inline
       void
       build(
         real_type const * x,
         real_type const * y,
         real_type const * yp,
         integer n
       ) {
         this->build( x, 1, y, 1, yp, 1, n );
       }
   
       void
       build(
         vector<real_type> const & x,
         vector<real_type> const & y,
         vector<real_type> const & yp
       );
   
       void clear() override;
   
       integer // order
       coeffs(
         real_type * const cfs,
         real_type * const nodes,
         bool              transpose = false
       ) const override;
   
       integer order() const override;
   
     };
   
     /*\
      |   ____        _ _            ____              __
      |  / ___| _ __ | (_)_ __   ___/ ___| _   _ _ __ / _|
      |  \___ \| '_ \| | | '_ \ / _ \___ \| | | | '__| |_
      |   ___) | |_) | | | | | |  __/___) | |_| | |  |  _|
      |  |____/| .__/|_|_|_| |_|\___|____/ \__,_|_|  |_|
      |        |_|
     \*/
     class SplineSurf {
   
       SplineSurf( SplineSurf const & ) = delete; // block copy constructor
       SplineSurf const & operator = ( SplineSurf const & ) = delete; // block copy method
   
       Utils::Malloc<real_type> m_mem;
   
     protected:
   
       string const m_name;
       bool         m_x_closed;
       bool         m_y_closed;
       bool         m_x_can_extend;
       bool         m_y_can_extend;
   
       integer      m_nx;
       integer      m_ny;
   
       real_type *  m_X;
       real_type *  m_Y;
       real_type *  m_Z;
   
       real_type m_Z_min, m_Z_max;
   
       mutable Utils::BinarySearch<integer> m_bs_x;
       mutable Utils::BinarySearch<integer> m_bs_y;
   
       integer search_x( real_type & x ) const;
       integer search_y( real_type & y ) const;
   
       void initLastInterval_x();
       void initLastInterval_y();
   
       integer
       ipos_C( integer i, integer j, integer ldZ ) const
       { return i*ldZ + j; }
   
       integer
       ipos_F( integer i, integer j, integer ldZ ) const
       { return i + ldZ*j; }
   
       integer
       ipos_C( integer i, integer j ) const
       { return this->ipos_C(i,j,m_ny); }
   
       integer
       ipos_F( integer i, integer j ) const
       { return this->ipos_F(i,j,m_nx); }
   
       virtual void makeSpline() = 0;
   
     public:
   
       SplineSurf( string const & name = "Spline" )
       : m_mem("SplineSurf")
       , m_name(name)
       , m_x_closed(false)
       , m_y_closed(false)
       , m_x_can_extend(true)
       , m_y_can_extend(true)
       , m_nx(0)
       , m_ny(0)
       , m_X(nullptr)
       , m_Y(nullptr)
       , m_Z(nullptr)
       , m_Z_min(0)
       , m_Z_max(0)
       {
         this->initLastInterval_x();
         this->initLastInterval_y();
       }
   
       virtual
       ~SplineSurf();
   
       bool is_x_closed() const { return m_x_closed; }
   
       void make_x_closed() { m_x_closed = true; }
   
       void make_x_opened() { m_x_closed = false; }
   
       bool is_y_closed() const { return m_y_closed; }
   
       void make_y_closed() { m_y_closed = true; }
   
       void make_y_opened() { m_y_closed = false; }
   
       bool is_x_bounded() const { return m_x_can_extend; }
       void make_x_unbounded() { m_x_can_extend = true; }
       void make_x_bounded() { m_x_can_extend = false; }
   
       bool is_y_bounded() const { return m_y_can_extend; }
       void make_y_unbounded() { m_y_can_extend = true; }
       void make_y_bounded() { m_y_can_extend = false; }
   
       string const & name() const { return m_name; }
   
       void clear();
   
       integer numPointX() const { return m_nx; }
   
       integer numPointY() const { return m_ny; }
   
       real_type xNode( integer i ) const { return m_X[size_t(i)]; }
   
       real_type yNode( integer i ) const { return m_Y[size_t(i)]; }
   
       real_type
       zNode( integer i, integer j ) const
       { return m_Z[size_t(this->ipos_C(i,j))]; }
   
       real_type xMin() const { return m_X[0]; }
   
       real_type xMax() const { return m_X[m_nx-1]; }
   
       real_type yMin() const { return m_Y[0]; }
   
       real_type yMax() const { return m_Y[m_ny-1]; }
   
       real_type zMin() const { return m_Z_min; }
   
       real_type zMax() const { return m_Z_max; }
   
   
       void
       build(
         real_type const * x, integer incx,
         real_type const * y, integer incy,
         real_type const * z, integer ldZ,
         integer nx, integer ny,
         bool fortran_storage = false,
         bool transposed      = false
       );
   
       void
       build(
         vector<real_type> const & x,
         vector<real_type> const & y,
         vector<real_type> const & z,
         bool fortran_storage = false,
         bool transposed      = false
       ) {
         bool xyswp = (fortran_storage && transposed) ||
                      (!fortran_storage && !transposed);
         this->build(
           &x.front(), 1,
           &y.front(), 1,
           &z.front(), integer(xyswp ? y.size() : x.size()),
           integer(x.size()), integer(y.size()),
           fortran_storage, transposed
         );
       }
   
       void
       build(
         real_type const * z,
         integer           ldZ,
         integer           nx,
         integer           ny,
         bool fortran_storage = false,
         bool transposed      = false
       );
   
       void
       build(
         vector<real_type> const & z,
         integer                   nx,
         integer                   ny,
         bool fortran_storage = false,
         bool transposed      = false
       ) {
         if ( fortran_storage )
           this->build( &z.front(), nx, nx, ny, fortran_storage, transposed );
         else
           this->build( &z.front(), ny, nx, ny, fortran_storage, transposed );
       }
   
       void
       setup( GenericContainer const & gc );
   
       void
       build ( GenericContainer const & gc )
       { setup(gc); }
   
       virtual
       real_type
       operator () ( real_type x, real_type y ) const = 0;
   
       virtual
       void
       D( real_type x, real_type y, real_type d[3] ) const = 0;
   
       virtual
       real_type
       Dx( real_type x, real_type y ) const = 0;
   
       virtual
       real_type
       Dy( real_type x, real_type y ) const = 0;
   
       virtual
       void
       DD( real_type x, real_type y, real_type dd[6] ) const = 0;
   
       virtual
       real_type
       Dxx( real_type x, real_type y ) const = 0;
   
       virtual
       real_type
       Dxy( real_type x, real_type y ) const = 0;
   
       virtual
       real_type
       Dyy( real_type x, real_type y ) const = 0;
   
       real_type
       eval( real_type x, real_type y ) const
       { return (*this)(x,y); }
   
       real_type
       eval_D_1( real_type x, real_type y ) const
       { return this->Dx(x,y); }
   
       real_type
       eval_D_2( real_type x, real_type y ) const
       { return this->Dy(x,y); }
   
       real_type
       eval_D_1_1( real_type x, real_type y ) const
       { return this->Dxx(x,y); }
   
       real_type
       eval_D_1_2( real_type x, real_type y ) const
       { return this->Dxy(x,y); }
   
       real_type
       eval_D_2_2( real_type x, real_type y ) const
       { return this->Dyy(x,y); }
   
       virtual void writeToStream( ostream_type & s ) const = 0;
   
       virtual char const * type_name() const = 0;
   
       virtual string info() const;
   
       void
       info( ostream_type & stream ) const
       { stream << this->info() << '\n'; }
   
     };
   
   }
   
   #include "SplineAkima.hxx"
   #include "SplineBessel.hxx"
   #include "SplineConstant.hxx"
   #include "SplineLinear.hxx"
   #include "SplineCubic.hxx"
   #include "SplineHermite.hxx"
   #include "SplinePchip.hxx"
   #include "SplineQuinticBase.hxx"
   #include "SplineQuintic.hxx"
   #include "SplineBilinear.hxx"
   #include "SplineBiCubic.hxx"
   #include "SplineAkima2D.hxx"
   #include "SplineBiQuintic.hxx"
   
   #include "SplineVec.hxx"
   #include "SplineSet.hxx"
   #include "Splines1D.hxx"
   #include "Splines2D.hxx"
   
   #ifndef DOXYGEN_SHOULD_SKIP_THIS
   
   namespace SplinesLoad {
   
     using Splines::Spline;
     using Splines::CubicSplineBase;
     using Splines::CubicSpline;
     using Splines::AkimaSpline;
     using Splines::BesselSpline;
     using Splines::PchipSpline;
     using Splines::LinearSpline;
     using Splines::ConstantSpline;
     using Splines::QuinticSpline;
     using Splines::Spline1D;
   
     using Splines::BilinearSpline;
     using Splines::BiCubicSpline;
     using Splines::BiQuinticSpline;
     using Splines::Akima2Dspline;
     using Splines::Spline2D;
   
     using Splines::SplineVec;
     using Splines::SplineSet;
   
     using Splines::SplineType1D;
     using Splines::SplineType2D;
   }
   
   #endif
   
   #ifdef __GNUC__
   #pragma GCC diagnostic pop
   #endif
   #ifdef __clang__
   #pragma clang diagnostic pop
   #endif
   
   #endif
